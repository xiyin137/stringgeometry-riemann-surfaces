/-
Copyright (c) 2025. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: ModularPhysics Contributors
-/
import StringGeometry.Topology.Homotopy.Constructions
import StringGeometry.Topology.Homotopy.Suspension
import StringGeometry.Topology.Homotopy.WeakEquivalence
import Mathlib.Logic.Relation

/-!
# Cofiber and Fiber Sequences

This file defines the mapping cone (cofiber) and mapping fiber (homotopy fiber)
constructions for pointed topological spaces.

## Main Definitions

* `PointedTopSpace.mappingCone` - The mapping cone / cofiber Cf of f : A → X
* `PointedTopSpace.cofiberInclusion` - The inclusion X → Cf
* `PointedTopSpace.homotopyFiber` - The homotopy fiber Ff of f : X → Y

## Mathematical Background

For a map f : A → X of pointed spaces:

### Mapping Cone (Cofiber)
The mapping cone Cf is defined as:
  Cf = X ∪_f CA = (X ⊔ (A × I)) / ~
where we identify:
  - f(a) with (a, 1) for all a ∈ A
  - (a, 0) with the basepoint for all a ∈ A
  - (basepoint_A, t) with the basepoint for all t ∈ I

This gives the cofiber sequence:
  A → X → Cf → ΣA → ΣX → ΣCf → ...

### Mapping Fiber (Homotopy Fiber)
The homotopy fiber Ff is defined as:
  Ff = {(x, γ) ∈ X × Y^I : γ(0) = f(x), γ(1) = y₀}

This gives the fiber sequence:
  ... → ΩY → Ff → X → Y

## References

* May, "A Concise Course in Algebraic Topology", Chapter 8
* Hatcher, "Algebraic Topology", Chapter 0
-/

universe u

open CategoryTheory TopologicalSpace unitInterval Relation

namespace PointedTopSpace

variable {A X Y : PointedTopSpace.{0}}

/-! ## Mapping Cone (Cofiber)

We define the mapping cone using the reduced cone construction.
For a map f : A → X, the mapping cone Cf is:
  Cf = (X ⊔ CA) / (f(a) ~ cone point of a)
where CA is the reduced cone on A.
-/

section MappingCone

/-- The type for the mapping cone before quotienting:
    the disjoint union of X and the reduced cone CA. -/
def MappingConePreType (A X : PointedTopSpace.{0}) : Type :=
  X.carrier ⊕ (reducedCone A).carrier

/-- The disjoint union has the sum topology. -/
instance (A X : PointedTopSpace.{0}) : TopologicalSpace (MappingConePreType A X) :=
  instTopologicalSpaceSum

/-- The basic relation for the mapping cone:
    - Identify f(a) ∈ X with the cone point (a, 1) ∈ CA
    - Identify basepoints of X and CA -/
def mappingConeBasicRel (f : A ⟶ X) : MappingConePreType A X → MappingConePreType A X → Prop :=
  fun p q =>
    -- Identify f(a) ∈ X with (a, 1) ∈ CA
    (∃ a : A.carrier,
      (p = Sum.inl (f.toFun a) ∧ q = Sum.inr ((coneBase A).toFun a)) ∨
      (q = Sum.inl (f.toFun a) ∧ p = Sum.inr ((coneBase A).toFun a))) ∨
    -- Identify basepoints
    ((p = Sum.inl X.basepoint ∧ q = Sum.inr (reducedCone A).basepoint) ∨
     (q = Sum.inl X.basepoint ∧ p = Sum.inr (reducedCone A).basepoint))

/-- The setoid for the mapping cone using equivalence relation generated by basic relation. -/
def mappingConeSetoid (f : A ⟶ X) : Setoid (MappingConePreType A X) :=
  EqvGen.setoid (mappingConeBasicRel f)

/-- The underlying type of the mapping cone. -/
def MappingConeType (f : A ⟶ X) : Type := Quotient (mappingConeSetoid f)

/-- The mapping cone inherits the quotient topology. -/
instance (f : A ⟶ X) : TopologicalSpace (MappingConeType f) :=
  instTopologicalSpaceQuotient

/-- The basepoint of the mapping cone. -/
def mappingConeBasepoint (f : A ⟶ X) : MappingConeType f :=
  Quotient.mk (mappingConeSetoid f) (Sum.inl X.basepoint)

/-- The mapping cone of f : A → X. -/
def mappingCone (f : A ⟶ X) : PointedTopSpace.{0} where
  carrier := MappingConeType f
  topology := inferInstance
  basepoint := mappingConeBasepoint f

/-- Notation for mapping cone. -/
scoped notation "Cf" => mappingCone

/-- The inclusion X → Cf. -/
def cofiberInclusion (f : A ⟶ X) : X ⟶ Cf f where
  toFun := fun x => Quotient.mk (mappingConeSetoid f) (Sum.inl x)
  continuous_toFun := continuous_quotient_mk'.comp continuous_inl
  map_basepoint := rfl

/-- The quotient map from CA → Cf. -/
def coneToCofiber (f : A ⟶ X) : reducedCone A ⟶ Cf f where
  toFun := fun c => Quotient.mk (mappingConeSetoid f) (Sum.inr c)
  continuous_toFun := continuous_quotient_mk'.comp continuous_inr
  map_basepoint := by
    simp only [mappingCone, mappingConeBasepoint]
    apply Quotient.sound
    apply EqvGen.rel
    -- Use the basepoint identification: (q = Sum.inl X.basepoint ∧ p = Sum.inr (CA).basepoint)
    right; right
    exact ⟨rfl, rfl⟩

/-- The cofiber sequence: A → X → Cf.
    The composition f followed by inclusion into Cf is nullhomotopic
    (factors through the contractible cone CA). -/
theorem cofiber_composition (f : A ⟶ X) :
    ∀ a : A.carrier, (cofiberInclusion f).toFun (f.toFun a) =
      (coneToCofiber f).toFun ((coneBase A).toFun a) := by
  intro a
  simp only [cofiberInclusion, coneToCofiber]
  apply Quotient.sound
  apply EqvGen.rel
  left
  exact ⟨a, Or.inl ⟨rfl, rfl⟩⟩

/-! ### The Map from Cone to Suspension: CA → ΣA

The reduced cone CA = A ∧ I₊ and reduced suspension ΣA are both quotients of A × I,
but with different equivalence relations:
- CA collapses: {a₀} × I and A × {0}
- ΣA collapses: {a₀} × I and A × {0} and A × {1}

The natural map CA → ΣA quotients further by A × {1}. -/

/-- The map from A × I (before smash quotient) to ΣA. -/
def conePreToSuspension (A : PointedTopSpace.{0}) :
    A.carrier × pointedUnitInterval.carrier → (Σ₊ A).carrier :=
  fun p => suspensionQuotientMap A (p.1, p.2)

/-- The cone-to-suspension map respects the smash relation.
    If both points are in the wedge subset of A × I₊, they both map to basepoint of ΣA. -/
theorem conePreToSuspension_respects (A : PointedTopSpace.{0}) :
    ∀ p q : A.carrier × pointedUnitInterval.carrier,
      smashRel A pointedUnitInterval p q →
      conePreToSuspension A p = conePreToSuspension A q := by
  intro p q h
  simp only [conePreToSuspension, suspensionQuotientMap]
  cases h with
  | inl h => rw [h]
  | inr h =>
    -- Both in wedge subset: (x = a₀ or t = 0)
    apply Quotient.sound
    right
    constructor
    · -- p is in collapsed set of ΣA
      unfold inWedgeSubset at h
      cases h.1 with
      | inl hp => right; right; exact hp
      | inr hp =>
        -- hp : p.2 = pointedUnitInterval.basepoint = ⟨0, _⟩
        left
        simp only [pointedUnitInterval, of] at hp
        rw [hp]; rfl
    · -- q is in collapsed set of ΣA
      unfold inWedgeSubset at h
      cases h.2 with
      | inl hq => right; right; exact hq
      | inr hq =>
        left
        simp only [pointedUnitInterval, of] at hq
        rw [hq]; rfl

/-- The map from the reduced cone CA to the reduced suspension ΣA.
    This is the natural quotient map that additionally collapses A × {1}. -/
def coneToSuspension (A : PointedTopSpace.{0}) : reducedCone A ⟶ Σ₊ A where
  toFun := Quotient.lift (conePreToSuspension A) (conePreToSuspension_respects A)
  continuous_toFun := by
    apply Continuous.quotient_lift
    unfold conePreToSuspension
    exact (continuous_suspensionQuotientMap A).comp
      (continuous_fst.prodMk continuous_snd)
  map_basepoint := by
    -- The basepoint of CA maps to basepoint of ΣA
    simp only [reducedCone, smashProduct, smashBasepoint]
    show Quotient.lift (conePreToSuspension A) _ (Quotient.mk _ (A.basepoint, _)) = _
    simp only [Quotient.lift_mk, conePreToSuspension, suspensionQuotientMap]
    apply Quotient.sound
    right
    constructor
    · right; right; rfl
    · left; rfl

/-! ### Connecting Map Cf → ΣA

The connecting map in the cofiber sequence sends:
- Points from X to the basepoint of ΣA
- Points from CA to ΣA via coneToSuspension

This is well-defined because f(a) ~ (a, 1) in Cf, and both map to the basepoint of ΣA
(X maps to basepoint, and (a,1) maps to [a,1] = basepoint since A × {1} is collapsed in ΣA). -/

/-- Helper: the auxiliary map from MappingConePreType to ΣA.
    - On X: constant map to basepoint
    - On CA: the coneToSuspension map -/
def connectingMapAux (_f : A ⟶ X) : MappingConePreType A X → (Σ₊ A).carrier := fun p =>
  match p with
  | Sum.inl _ => (Σ₊ A).basepoint  -- X maps to basepoint
  | Sum.inr c => (coneToSuspension A).toFun c  -- CA maps via coneToSuspension

/-- The connecting map preserves the basic relation.
    Key fact: f(a) ~ (a, 1) in Cf, and both map to basepoint in ΣA. -/
theorem connectingMapAux_respects_rel (f : A ⟶ X) :
    ∀ p q : MappingConePreType A X, mappingConeBasicRel f p q →
      connectingMapAux f p = connectingMapAux f q := by
  intro p q h
  simp only [connectingMapAux]
  cases h with
  | inl h =>
    -- f(a) ~ (a, 1) case
    obtain ⟨a, h⟩ := h
    cases h with
    | inl h =>
      -- p = Sum.inl (f a), q = Sum.inr (coneBase a)
      simp only [h.1, h.2]
      -- LHS is basepoint (from X)
      -- RHS: (coneBase A).toFun a = (a, 1) in CA, which maps to [a, 1] in ΣA = basepoint
      symm
      simp only [coneToSuspension, coneBase, smashQuotientMap, Quotient.lift_mk,
                 conePreToSuspension, suspensionQuotientMap]
      apply Quotient.sound
      right
      constructor
      · -- (a, 1) is in collapsed set (A × {1})
        right; left; rfl
      · -- basepoint (a₀, 0) is in collapsed set
        left; rfl
    | inr h =>
      -- q = Sum.inl (f a), p = Sum.inr (coneBase a)
      simp only [h.1, h.2]
      simp only [coneToSuspension, coneBase, smashQuotientMap, Quotient.lift_mk,
                 conePreToSuspension, suspensionQuotientMap]
      apply Quotient.sound
      right
      constructor
      · right; left; rfl
      · left; rfl
  | inr h =>
    -- Basepoint identification case
    cases h with
    | inl h =>
      simp only [h.1, h.2]
      -- LHS is basepoint of ΣA, RHS is coneToSuspension of basepoint of CA
      exact (coneToSuspension A).map_basepoint.symm
    | inr h =>
      simp only [h.1, h.2]
      exact (coneToSuspension A).map_basepoint

/-- The connecting map respects the equivalence relation generated by the basic relation. -/
theorem connectingMapAux_respects (f : A ⟶ X) :
    ∀ p q : MappingConePreType A X, (mappingConeSetoid f).r p q →
      connectingMapAux f p = connectingMapAux f q := by
  intro p q h
  -- h : EqvGen (mappingConeBasicRel f) p q
  induction h with
  | rel _ _ hr => exact connectingMapAux_respects_rel f _ _ hr
  | refl _ => rfl
  | symm _ _ _ ih => exact ih.symm
  | trans _ _ _ _ _ ih1 ih2 => exact ih1.trans ih2

/-- The connecting map Cf → ΣA in the cofiber sequence.
    This sends X to basepoint and CA to ΣA via the natural quotient map. -/
def connectingMap (f : A ⟶ X) : Cf f ⟶ Σ₊ A where
  toFun := Quotient.lift (connectingMapAux f) (connectingMapAux_respects f)
  continuous_toFun := by
    apply Continuous.quotient_lift
    -- Need to show connectingMapAux is continuous on MappingConePreType = X ⊕ CA
    apply continuous_sum_dom.mpr
    constructor
    · -- On X: constant map to basepoint
      exact continuous_const
    · -- On CA: coneToSuspension is continuous
      exact (coneToSuspension A).continuous
  map_basepoint := rfl

end MappingCone

/-! ## Mapping Fiber (Homotopy Fiber)

The homotopy fiber Ff of f : X → Y is defined as the pullback:
  Ff = {(x, γ) ∈ X × Y^I : γ(0) = f(x), γ(1) = y₀}

We use the based path space: paths in Y starting at some point and ending at y₀.
-/

section MappingFiber

/-- The space of paths in Y ending at the basepoint.
    This is ΩY with a forgotten starting point constraint. -/
def PathsToBaseType (Y : PointedTopSpace.{0}) : Type :=
  { γ : C(I, Y.carrier) // γ 1 = Y.basepoint }

/-- The paths-to-base space has the subspace topology from C(I, Y). -/
instance (Y : PointedTopSpace.{0}) : TopologicalSpace (PathsToBaseType Y) :=
  instTopologicalSpaceSubtype

/-- The homotopy fiber of f : X → Y is the subspace of X × PathsToBase(Y)
    consisting of pairs (x, γ) where γ(0) = f(x). -/
def HomotopyFiberType (f : X ⟶ Y) : Type :=
  { p : X.carrier × PathsToBaseType Y // p.2.val 0 = f.toFun p.1 }

/-- The homotopy fiber has the subspace topology. -/
instance (f : X ⟶ Y) : TopologicalSpace (HomotopyFiberType f) :=
  instTopologicalSpaceSubtype

/-- The constant path at the basepoint (a loop). -/
def constPathToBase (Y : PointedTopSpace.{0}) : PathsToBaseType Y :=
  ⟨ContinuousMap.const I Y.basepoint, rfl⟩

/-- The basepoint of the homotopy fiber: (x₀, constant path at y₀). -/
def homotopyFiberBasepoint (f : X ⟶ Y) : HomotopyFiberType f :=
  ⟨(X.basepoint, constPathToBase Y), by simp [constPathToBase, f.map_basepoint]⟩

/-- The homotopy fiber as a pointed space. -/
def homotopyFiber (f : X ⟶ Y) : PointedTopSpace.{0} where
  carrier := HomotopyFiberType f
  topology := inferInstance
  basepoint := homotopyFiberBasepoint f

/-- Notation for homotopy fiber. -/
scoped notation "Ff" => homotopyFiber

/-- The projection Ff → X. -/
def fiberProjection (f : X ⟶ Y) : Ff f ⟶ X where
  toFun := fun p => p.val.1
  continuous_toFun := by
    apply Continuous.comp continuous_fst
    exact continuous_subtype_val
  map_basepoint := rfl

/-- The fiber sequence property: the path in Ff witnesses that f(x) is connected to y₀. -/
theorem fiber_path_property (f : X ⟶ Y) (p : HomotopyFiberType f) :
    p.val.2.val 0 = f.toFun p.val.1 ∧ p.val.2.val 1 = Y.basepoint :=
  ⟨p.property, p.val.2.property⟩

/-! ### Fiber Sequence Map: ΩY → Ff

The fiber sequence ... → ΩY → Ff → X → Y has a connecting map ΩY → Ff.
A loop γ in ΩY (based at y₀) maps to (x₀, γ) in Ff, which is valid since:
- γ is a path ending at y₀ (since γ(1) = y₀)
- γ(0) = y₀ = f(x₀) (since loops start at basepoint and f preserves basepoints) -/

/-- Convert a loop in ΩY to a path ending at basepoint (for PathsToBaseType).
    A loop γ : Path y₀ y₀ satisfies γ(1) = y₀, so it's in PathsToBaseType. -/
def loopToPathsToBase (Y : PointedTopSpace.{0}) (γ : LoopSpaceType Y) : PathsToBaseType Y :=
  ⟨γ.toContinuousMap, γ.target⟩

/-- The loop-to-path conversion is continuous. -/
theorem continuous_loopToPathsToBase (Y : PointedTopSpace.{0}) :
    Continuous (loopToPathsToBase Y) := by
  apply Continuous.subtype_mk
  exact continuous_induced_dom

/-- The fiber sequence map ΩY → Ff.
    This sends a loop γ based at y₀ to (x₀, γ) in Ff. -/
def fiberInclusionFromLoop (f : X ⟶ Y) : Ω Y ⟶ Ff f where
  toFun := fun γ =>
    ⟨(X.basepoint, loopToPathsToBase Y γ), by
      -- Need to show: (loopToPathsToBase Y γ).val 0 = f.toFun X.basepoint
      simp only [loopToPathsToBase]
      -- γ.toContinuousMap 0 = γ 0 = γ.source = Y.basepoint
      have hsource : γ.toContinuousMap 0 = Y.basepoint := γ.source
      rw [hsource]
      -- f.toFun X.basepoint = Y.basepoint (basepoint preservation)
      exact f.map_basepoint.symm⟩
  continuous_toFun := by
    -- Need to show continuity of γ ↦ (x₀, loopToPathsToBase Y γ)
    apply Continuous.subtype_mk
    exact continuous_const.prodMk (continuous_loopToPathsToBase Y)
  map_basepoint := by
    -- Need to show: fiberInclusionFromLoop maps constLoop to homotopyFiberBasepoint
    simp only [loopSpace, homotopyFiber, homotopyFiberBasepoint]
    apply Subtype.ext
    simp only [Prod.mk.injEq]
    constructor
    · trivial
    · -- loopToPathsToBase Y (constLoop Y) = constPathToBase Y
      simp only [loopToPathsToBase, constLoop, constPathToBase]
      apply Subtype.ext
      rfl

/-- The fiber sequence: ΩY → Ff → X → Y.
    Composing fiberInclusionFromLoop with fiberProjection gives the constant map at x₀. -/
theorem fiber_sequence_composition (f : X ⟶ Y) :
    ∀ γ : LoopSpaceType Y, (fiberProjection f).toFun ((fiberInclusionFromLoop f).toFun γ) = X.basepoint :=
  fun _ => rfl

end MappingFiber

/-! ## Puppe Sequence

The cofiber sequence extends to an infinite sequence:
  A → X → Cf → ΣA → ΣX → Σ(Cf) → Σ²A → ...
-/

section PuppeSequence

/-- The Puppe sequence of spaces: A, X, Cf, ΣA, ΣX, ΣCf, Σ²A, ... -/
def puppeSequence (f : A ⟶ X) : ℕ → PointedTopSpace.{0}
  | 0 => A
  | 1 => X
  | 2 => Cf f
  | n + 3 => Σ₊ (puppeSequence f n)

end PuppeSequence

/-! ## Long Exact Sequence of Homotopy Groups

For a fiber sequence ΩY → Ff → X → Y, we get a long exact sequence:
  ... → π_{n+1}(Y) → π_n(Ff) → π_n(X) → π_n(Y) → π_{n-1}(Ff) → ...

Similarly, for a cofiber sequence A → X → Cf, we get:
  ... → π_n(A) → π_n(X) → π_n(Cf) → π_{n-1}(A) → ...

The connecting maps come from the fiber/cofiber constructions.
-/

section LongExactSequence

variable {A X Y : PointedTopSpace.{0}}

/-- The induced map on homotopy groups from fiberProjection. -/
def fiberProjectionInduced (f : X ⟶ Y) (n : ℕ) :
    HomotopyGroup.Pi n (Ff f).carrier (Ff f).basepoint →
    HomotopyGroup.Pi n X.carrier X.basepoint :=
  inducedπ n (fiberProjection f)

/-- The induced map on homotopy groups from fiberInclusionFromLoop. -/
def fiberInclusionInduced (f : X ⟶ Y) (n : ℕ) :
    HomotopyGroup.Pi n (Ω Y).carrier (Ω Y).basepoint →
    HomotopyGroup.Pi n (Ff f).carrier (Ff f).basepoint :=
  inducedπ n (fiberInclusionFromLoop f)

/-- The induced map on homotopy groups from cofiberInclusion. -/
def cofiberInclusionInduced (f : A ⟶ X) (n : ℕ) :
    HomotopyGroup.Pi n X.carrier X.basepoint →
    HomotopyGroup.Pi n (Cf f).carrier (Cf f).basepoint :=
  inducedπ n (cofiberInclusion f)

/-- The induced map on homotopy groups from the connecting map. -/
def connectingMapInduced (f : A ⟶ X) (n : ℕ) :
    HomotopyGroup.Pi n (Cf f).carrier (Cf f).basepoint →
    HomotopyGroup.Pi n (Σ₊ A).carrier (Σ₊ A).basepoint :=
  inducedπ n (connectingMap f)

/-- The fiber sequence at level n: the composition ΩY → Ff → X is nullhomotopic,
    meaning fiberProjectionInduced ∘ fiberInclusionInduced is the constant map. -/
theorem fiber_sequence_exact_at_Ff (f : X ⟶ Y) (n : ℕ) :
    ∀ α : HomotopyGroup.Pi n (Ω Y).carrier (Ω Y).basepoint,
      fiberProjectionInduced f n (fiberInclusionInduced f n α) =
      ⟦GenLoop.const⟧ := by
  intro α
  simp only [fiberProjectionInduced, fiberInclusionInduced]
  induction α using Quotient.ind with
  | _ γ =>
    simp only [inducedπ, Quotient.map'_mk'']
    apply Quotient.sound
    -- The composed induced genloop is homotopic to GenLoop.const
    -- because the composition ΩY → Ff → X is constant (= x₀)
    -- We need to show: inducedGenLoop (fiberProjection f) (inducedGenLoop (fiberInclusionFromLoop f) γ)
    --                  is homotopic to GenLoop.const
    -- This is true because both evaluate to x₀ at every point.
    -- The composition sends γ(t) ↦ (x₀, γ(t)) ↦ x₀ for all t.
    have hconst : (inducedGenLoop (Fin n) (fiberProjection f)
        (inducedGenLoop (Fin n) (fiberInclusionFromLoop f) γ)).val =
        (GenLoop.const : GenLoop (Fin n) X.carrier X.basepoint).val := by
      ext t
      simp only [inducedGenLoop, toContinuousMap, fiberProjection, fiberInclusionFromLoop,
                 ContinuousMap.comp_apply, GenLoop.const, ContinuousMap.const_apply]
      rfl
    -- Equal genloops are homotopic
    have heq : inducedGenLoop (Fin n) (fiberProjection f)
        (inducedGenLoop (Fin n) (fiberInclusionFromLoop f) γ) =
        (GenLoop.const : GenLoop (Fin n) X.carrier X.basepoint) := by
      apply Subtype.ext
      exact hconst
    rw [heq]

/-- The cofiber sequence at level n: the composition A → X → Cf equals
    the composition A → CA → Cf at the function level.
    This follows from `cofiber_composition` which states that for any a ∈ A,
    f(a) and (a,1) are identified in Cf. -/
theorem cofiber_sequence_paths_equal (f : A ⟶ X) :
    ∀ a : A.carrier,
      (cofiberInclusion f).toFun (f.toFun a) =
      (coneToCofiber f).toFun ((coneBase A).toFun a) :=
  cofiber_composition f

/-- The induced map (cofiberInclusion f) ∘ f on homotopy groups equals
    the induced map (coneToCofiber f) ∘ (coneBase A).
    Both compositions go from A to Cf. -/
theorem cofiber_sequence_composition_induced (f : A ⟶ X) (n : ℕ) :
    ∀ α : HomotopyGroup.Pi n A.carrier A.basepoint,
      cofiberInclusionInduced f n (inducedπ n f α) =
      inducedπ n (coneBase A ≫ coneToCofiber f) α := by
  intro α
  -- By functoriality: (cofiberInclusion f) ∘ f = (coneToCofiber f) ∘ (coneBase A)
  -- as maps A → Cf, so they induce the same map on homotopy groups.
  -- First, reduce to showing the compositions are equal as morphisms
  have hcomp : (f ≫ cofiberInclusion f) = (coneBase A ≫ coneToCofiber f) := by
    apply Hom.ext
    funext a
    simp only [comp_toFun, Function.comp_apply]
    exact cofiber_composition f a
  -- Now use functoriality
  simp only [cofiberInclusionInduced]
  -- inducedπ n (cofiberInclusion f) (inducedπ n f α) = (inducedπ n (cofiberInclusion f) ∘ inducedπ n f) α
  -- = inducedπ n (f ≫ cofiberInclusion f) α
  have h1 : inducedπ n (cofiberInclusion f) (inducedπ n f α) =
            inducedπ n (f ≫ cofiberInclusion f) α := by
    have heq := inducedπ_comp n f (cofiberInclusion f)
    exact congrFun heq.symm α
  rw [h1, hcomp]

/-! ### Infrastructure for fiber sequence exactness -/

/-- The constant GenLoop at the basepoint of Y. -/
abbrev constGenLoopY (Y : PointedTopSpace) (n : ℕ) : GenLoop (Fin n) Y.carrier Y.basepoint :=
  GenLoop.const

/-- Given a homotopy H : I × I^n → Y from (f ∘ γ) to const y₀,
    for each t ∈ I^n we get a path from f(γ(t)) to y₀ by currying. -/
def homotopyToPathsToBase {n : ℕ} {f : X ⟶ Y} {γ : GenLoop (Fin n) X.carrier X.basepoint}
    (H : ContinuousMap.HomotopyRel (inducedGenLoop (Fin n) f γ).val
          (constGenLoopY Y n).val (Cube.boundary (Fin n)))
    (t : (Fin n → I)) : PathsToBaseType Y where
  val := ⟨fun s => H (s, t), H.continuous.comp (continuous_id.prodMk continuous_const)⟩
  property := by
    -- H(1, t) = const(t) = Y.basepoint
    show H (1, t) = Y.basepoint
    exact H.apply_one t

/-- The curried homotopy function is continuous in t. -/
theorem continuous_homotopyToPathsToBase {n : ℕ} {f : X ⟶ Y}
    {γ : GenLoop (Fin n) X.carrier X.basepoint}
    (H : ContinuousMap.HomotopyRel (inducedGenLoop (Fin n) f γ).val
          (constGenLoopY Y n).val (Cube.boundary (Fin n))) :
    Continuous (homotopyToPathsToBase H) := by
  -- Need to show t ↦ (s ↦ H(s, t)) is continuous
  apply Continuous.subtype_mk
  -- The topology on C(I, Y) is compact-open
  -- We need: the uncurried map (t, s) ↦ H(s, t) is continuous
  -- This factors as: (t, s) ↦ (s, t) ↦ H(s, t)
  let g : (Fin n → I) → C(I, Y.carrier) := fun t =>
    ⟨fun s => H (s, t), H.continuous.comp (continuous_id.prodMk continuous_const)⟩
  refine ContinuousMap.continuous_of_continuous_uncurry g ?_
  show Continuous fun p : (Fin n → I) × I => H (p.2, p.1)
  exact H.continuous.comp (continuous_snd.prodMk continuous_fst)

/-- The lift to the homotopy fiber: given γ in the kernel of f_*,
    construct an element of Ff. -/
def fiberLift {n : ℕ} {f : X ⟶ Y} {γ : GenLoop (Fin n) X.carrier X.basepoint}
    (H : ContinuousMap.HomotopyRel (inducedGenLoop (Fin n) f γ).val
          (constGenLoopY Y n).val (Cube.boundary (Fin n)))
    (t : Fin n → I) : HomotopyFiberType f where
  val := (γ t, homotopyToPathsToBase H t)
  property := by
    -- Need: (homotopyToPathsToBase H t).val 0 = f.toFun (γ t)
    show H (0, t) = f.toFun (γ t)
    -- H(0, t) = (inducedGenLoop f γ)(t) = f(γ(t))
    have : H (0, t) = (inducedGenLoop (Fin n) f γ).val t := H.apply_zero t
    rw [this]
    rfl

/-- The fiber lift is continuous. -/
theorem continuous_fiberLift {n : ℕ} {f : X ⟶ Y} {γ : GenLoop (Fin n) X.carrier X.basepoint}
    (H : ContinuousMap.HomotopyRel (inducedGenLoop (Fin n) f γ).val
          (constGenLoopY Y n).val (Cube.boundary (Fin n))) :
    Continuous (fiberLift H) := by
  apply Continuous.subtype_mk
  exact γ.val.continuous.prodMk (continuous_homotopyToPathsToBase H)

/-- The fiber lift sends boundary points to the basepoint of Ff. -/
theorem fiberLift_boundary {n : ℕ} {f : X ⟶ Y} {γ : GenLoop (Fin n) X.carrier X.basepoint}
    (H : ContinuousMap.HomotopyRel (inducedGenLoop (Fin n) f γ).val
          (constGenLoopY Y n).val (Cube.boundary (Fin n)))
    (t : Fin n → I) (ht : t ∈ Cube.boundary (Fin n)) :
    fiberLift H t = homotopyFiberBasepoint f := by
  apply Subtype.ext
  simp only [fiberLift, homotopyFiberBasepoint, Prod.mk.injEq]
  constructor
  · -- First component: γ(t) = X.basepoint (since γ is a GenLoop)
    exact γ.property t ht
  · -- Second component: path is constant at Y.basepoint
    apply Subtype.ext
    apply ContinuousMap.ext
    intro s
    -- H(s, t) = (f ∘ γ)(t) for t on boundary (by HomotopyRel property)
    -- And (f ∘ γ)(t) = f(γ(t)) = f(x₀) = y₀ since γ(t) = x₀
    simp only [homotopyToPathsToBase, constPathToBase, ContinuousMap.coe_mk]
    -- H.prop says (H.curry s) t = (inducedGenLoop f γ)(t) for t in boundary
    -- Note: (H.curry s) t = H (s, t) by definition
    have hprop := H.prop s t ht
    -- hprop : (H.curry s) t = (inducedGenLoop f γ).val t
    -- Goal: H (s, t) = Y.basepoint
    -- First, H (s, t) = (H.curry s) t = (inducedGenLoop f γ).val t
    have heq : H (s, t) = (inducedGenLoop (Fin n) f γ).val t := hprop
    rw [heq]
    -- (inducedGenLoop f γ)(t) = f(γ(t)) = f(x₀) = y₀
    simp only [inducedGenLoop, toContinuousMap, ContinuousMap.comp_apply]
    rw [γ.property t ht]
    exact f.map_basepoint

/-- The fiber lift as a GenLoop in Ff. -/
def fiberLiftGenLoop {n : ℕ} {f : X ⟶ Y} {γ : GenLoop (Fin n) X.carrier X.basepoint}
    (H : ContinuousMap.HomotopyRel (inducedGenLoop (Fin n) f γ).val
          (constGenLoopY Y n).val (Cube.boundary (Fin n))) :
    GenLoop (Fin n) (Ff f).carrier (Ff f).basepoint where
  val := ⟨fiberLift H, continuous_fiberLift H⟩
  property := fiberLift_boundary H

/-- The projection of the fiber lift equals the original loop. -/
theorem fiberLiftGenLoop_proj {n : ℕ} {f : X ⟶ Y} {γ : GenLoop (Fin n) X.carrier X.basepoint}
    (H : ContinuousMap.HomotopyRel (inducedGenLoop (Fin n) f γ).val
          (constGenLoopY Y n).val (Cube.boundary (Fin n))) :
    inducedGenLoop (Fin n) (fiberProjection f) (fiberLiftGenLoop H) = γ := by
  apply GenLoop.ext
  intro t
  -- (fiberProjection ∘ fiberLift)(t) = first component of fiberLift(t) = γ(t)
  rfl

/-- Exactness of the fiber sequence: ker(f_*) = im(inclusion_*).
    An element of π_n(X) that maps to the basepoint class in π_n(Y) can be
    lifted to an element of π_n(Ff). -/
theorem fiber_sequence_ker_eq_im (f : X ⟶ Y) (n : ℕ) :
    ∀ α : HomotopyGroup.Pi n X.carrier X.basepoint,
      inducedπ n f α = ⟦GenLoop.const⟧ →
      ∃ β : HomotopyGroup.Pi n (Ff f).carrier (Ff f).basepoint,
        fiberProjectionInduced f n β = α := by
  -- This is the exactness property of the fiber sequence
  -- If f_*(α) is trivial, then α can be lifted through the fiber
  intro α hα
  -- Reduce to a representative
  induction α using Quotient.ind with
  | _ γ =>
    -- γ : GenLoop (Fin n) X.carrier X.basepoint
    -- hα : inducedπ n f ⟦γ⟧ = ⟦GenLoop.const⟧
    -- i.e., ⟦inducedGenLoop (Fin n) f γ⟧ = ⟦GenLoop.const⟧
    -- This means inducedGenLoop f γ is homotopic to GenLoop.const
    have hHomotopic : GenLoop.Homotopic (inducedGenLoop (Fin n) f γ) GenLoop.const := by
      simp only [inducedπ, Quotient.map'_mk''] at hα
      exact Quotient.exact hα
    -- Extract the homotopy
    obtain ⟨H⟩ := hHomotopic
    -- H : HomotopyRel (inducedGenLoop f γ).val GenLoop.const.val (Cube.boundary (Fin n))
    -- Construct the lift using fiberLiftGenLoop
    use ⟦fiberLiftGenLoop H⟧
    -- Show that the projection gives back ⟦γ⟧
    simp only [fiberProjectionInduced, inducedπ, Quotient.map'_mk'']
    apply Quotient.sound
    -- Need: inducedGenLoop (fiberProjection f) (fiberLiftGenLoop H) is homotopic to γ
    rw [fiberLiftGenLoop_proj]

end LongExactSequence

end PointedTopSpace
