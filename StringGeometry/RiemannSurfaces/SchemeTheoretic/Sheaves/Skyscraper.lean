/-
Copyright (c) 2026 ModularPhysics Authors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: ModularPhysics Contributors
-/
import StringGeometry.RiemannSurfaces.SchemeTheoretic.Cohomology.SheafCohomology
import StringGeometry.RiemannSurfaces.SchemeTheoretic.Helpers.FlasqueSheaves
import StringGeometry.RiemannSurfaces.SchemeTheoretic.Helpers.SkyscraperModuleConstruction
import StringGeometry.RiemannSurfaces.SchemeTheoretic.Helpers.SkyscraperCohomology

/-!
# Skyscraper Sheaves on Algebraic Curves

This file defines skyscraper sheaves at closed points of algebraic curves.
These are fundamental for the Riemann-Roch theorem, as they satisfy Ï‡(k_p) = 1.

## Main Definitions

* `skyscraperSheaf` - The skyscraper sheaf k_p at a point p
* `skyscraperSheaf_isCoherent` - k_p is coherent

## Main Results

* `h0_skyscraper` - hâ°(k_p) = 1
* `h1_skyscraper` - hÂ¹(k_p) = 0
* `euler_char_skyscraper` - Ï‡(k_p) = 1

## Scheme-Theoretic Construction

The skyscraper sheaf k_p at a closed point p is defined as:
- k_p(U) = Îº(p) if p âˆˆ U, else 0
- where Îº(p) is the residue field at p

For curves over â„‚, Îº(p) â‰… â„‚ by the `residueFieldIsComplex` axiom.

## References

* Hartshorne, "Algebraic Geometry", Chapter II, Exercise 1.17
* Stacks Project, Tag 0080 (Skyscraper sheaves)
-/

open AlgebraicGeometry CategoryTheory

namespace RiemannSurfaces.SchemeTheoretic

variable (C : AlgebraicCurve)

/-!
## Skyscraper Sheaf Definition

The skyscraper sheaf at a point p has stalk Îº(p) at p and 0 elsewhere.
For curves over â„‚, Îº(p) â‰… â„‚.
-/

/-- The underlying O_C-module for the skyscraper sheaf at point p.

    **Scheme-theoretic definition:**
    The skyscraper sheaf k_p is the pushforward of the residue field Îº(p)
    along the inclusion {p} â†’ C.

    For a closed point p on a curve C over â„‚:
    - Îº(p) = C.toScheme.residueField p â‰… â„‚ (by residueFieldIsComplex)
    - k_p(U) = Îº(p) if p âˆˆ U, else 0
    - The O_C-module structure: f Â· v = f(p) Â· v for f âˆˆ O_C(U), v âˆˆ Îº(p)

    **Construction using Mathlib:**
    1. Use `skyscraperPresheaf p Îº(p)` from Mathlib.Topology.Sheaves.Skyscraper
       - This gives a presheaf with k_p(U) = Îº(p) if p âˆˆ U, else terminal object
    2. The sheaf condition holds (by `skyscraperPresheaf_isSheaf`)
    3. The O_C-module structure uses:
       - `residueFieldModule p U hp : Module (Î“(C, U)) (C.toScheme.residueField p)`
       - This gives the scalar multiplication f Â· v = evalAtPoint(f) Â· v
    4. Package as `SheafOfModules C.toScheme.ringCatSheaf`

    **Key Mathlib components:**
    - `TopCat.Presheaf.skyscraperPresheaf` : The underlying presheaf
    - `skyscraperPresheaf_isSheaf` : Sheaf condition
    - `skyscraperPresheafStalkOfSpecializes` : Stalk at p is Îº(p)
    - `skyscraperPresheafStalkOfNotSpecializes` : Stalk at q â‰  p is terminal

    **Infrastructure from SkyscraperInfrastructure.lean:**
    - `evalAtPoint` : O_C(U) â†’+* Îº(p) for p âˆˆ U
    - `residueFieldModule` : Îº(p) is an O_C(U)-module for p âˆˆ U

    **Technical challenge:**
    The construction requires interfacing Mathlib's `SheafOfModules` API
    (which uses PresheafOfModules over a ring presheaf) with the skyscraper
    construction (which is a presheaf in a general category C with terminal
    objects). This interface requires showing that the module operations
    are compatible with the presheaf structure. -/
noncomputable def skyscraperModule (p : C.PointType) : OModule C.toScheme :=
  SkyscraperConstruction.constructSkyscraperModule (X := C.toScheme) p

/-- The skyscraper sheaf at p is coherent.

    **Proof sketch:**
    k_p is supported on a single point, which makes it automatically
    finitely generated as an O_C-module. On each affine chart,
    the module of sections is either Îº(p) â‰… â„‚ (1-dimensional) or 0. -/
instance skyscraperModule_isCoherent (p : C.PointType) :
    IsCoherent C.toScheme (skyscraperModule C p) where
  locallyPresentable := fun i => âŸ¨Iso.refl _âŸ©
  locallyFinitelyGenerated := fun i => by
    classical
    let U := Opposite.op (C.toScheme.affineCover.f i).opensRange
    -- The module of sections is skyscraperObj p U
    -- which is Îº(p) if p âˆˆ U, else PUnit (the zero module)
    -- Note: the dite in skyscraperObj can't be reduced by split_ifs because
    -- Classical.dec is opaque. We use fromKappa/toKappa to work abstractly.
    change Module.Finite â†‘(C.toScheme.presheaf.obj U)
      â†‘(SkyscraperConstruction.skyscraperObj (X := C.toScheme) p U)
    by_cases hp : (p : C.toScheme.carrier) âˆˆ U.unop
    Â· -- p âˆˆ U: sections are Îº(p), finitely generated by {fromKappa(1)}
      -- fromKappa(1) generates the module: every x = evalAtPoint(r) â€¢ fromKappa(1) for some r
      apply Module.Finite.of_surjective
        (LinearMap.toSpanSingleton _ _
          (SkyscraperConstruction.fromKappa (X := C.toScheme) p U hp (1 : C.toScheme.residueField p)))
      intro x
      -- Get the Îº(p) value of x via toKappa
      let v := SkyscraperConstruction.toKappa (X := C.toScheme) p U hp x
      -- By surjectivity of canonical map â„‚ â†’ Îº(p), find c with canonical(c) = v
      obtain âŸ¨c, hcâŸ© := (C.residueFieldIsComplex p).2 v
      -- Factor: â„‚ â†’ Î“(X,âŠ¤) â†’ O_X(U) â†’ Îº(p) to get the ring element r
      let globalSec : Î“(C.toScheme, âŠ¤) :=
        C.structureMorphism.appTop.hom ((Scheme.Î“SpecIso (CommRingCat.of â„‚)).inv.hom c)
      let r : â†‘(C.toScheme.presheaf.obj U) :=
        (C.toScheme.presheaf.map (homOfLE le_top).op).hom globalSec
      refine âŸ¨r, ?_âŸ©
      -- Show: r â€¢ fromKappa(1) = x
      -- Apply toKappa (injective) to reduce to Îº(p) level
      apply SkyscraperConstruction.toKappa_injective (X := C.toScheme) p U hp
      -- Simplify toSpanSingleton application to r â€¢ fromKappa(1)
      simp only [LinearMap.toSpanSingleton_apply]
      -- toKappa(r â€¢ fromKappa(1)) = evalAtPoint(r) * toKappa(fromKappa(1))
      rw [SkyscraperConstruction.toKappa_ring_smul (X := C.toScheme) p U hp r
        (SkyscraperConstruction.fromKappa (X := C.toScheme) p U hp 1)]
      -- toKappa(fromKappa(1)) = 1
      rw [SkyscraperConstruction.toKappa_fromKappa (X := C.toScheme) p U hp]
      rw [mul_one]
      -- Goal: evalAtPoint(r) = toKappa(x) (= v)
      -- r = res_{Uâ‰¤âŠ¤}(globalSec), use evalAtPoint_comp_restriction
      show evalAtPoint p U.unop hp r = v
      change evalAtPoint p U.unop hp
        ((C.toScheme.presheaf.map (homOfLE le_top).op).hom globalSec) = v
      rw [SkyscraperConstruction.evalAtPoint_comp_restriction
        p U.unop âŠ¤ hp (Set.mem_univ _) le_top globalSec]
      -- evalAtPoint_âŠ¤(globalSec) = canonicalToResidueField(c) = v
      exact hc
    Â· -- p âˆ‰ U: sections are PUnit, module is subsingleton hence finitely generated
      haveI : Subsingleton â†‘(SkyscraperConstruction.skyscraperObj (X := C.toScheme) p U) :=
        SkyscraperConstruction.skyscraperObj_subsingleton p U hp
      exact Module.Finite.of_finite

/-- The skyscraper sheaf k_p at a closed point p.

    This is the coherent sheaf with:
    - Stalk at p: Îº(p) â‰… â„‚
    - Stalk at q â‰  p: 0 -/
noncomputable def skyscraperSheaf (p : C.PointType) : CoherentSheaf C where
  toModule := skyscraperModule C p
  isCoherent := skyscraperModule_isCoherent C p

namespace SkyscraperSheaf

variable {C}
variable (p : C.PointType)

/-!
## Stalk Properties

The defining property of skyscraper sheaves: concentrated at a single point.
-/

/-- The stalk of k_p at p is the residue field Îº(p).

    For curves over â„‚, this is isomorphic to â„‚.

    **Mathematical content:**
    The stalk (k_p)_p â‰… Îº(p) as an abelian group. -/
theorem stalk_at_point :
    Nonempty (C.toScheme.presheaf.stalk p â‰… C.toScheme.presheaf.stalk p) := by
  -- TODO: Express the actual isomorphism (k_p)_p â‰… Îº(p)
  -- This requires infrastructure for stalks of skyscraper sheaves
  exact âŸ¨Iso.refl _âŸ©

/-- The stalk of k_p at any other point q â‰  p is zero.

    **Mathematical content:**
    (k_p)_q = 0 for q â‰  p. -/
theorem stalk_away (q : C.PointType) (hpq : p â‰  q) :
    -- The stalk at q is the initial/terminal object (zero in Ab)
    Nonempty (Limits.IsInitial (C.toScheme.presheaf.stalk q)) âˆ¨
    Nonempty (Limits.IsTerminal (C.toScheme.presheaf.stalk q)) := by
  -- TODO: Express that (k_p)_q = 0 for the skyscraper module
  sorry

/-!
## Global Sections

k_p has exactly one global section (the identity element of Îº(p)).
-/

/-- Global sections of k_p form a 1-dimensional â„‚-vector space.

    **Proof:**
    Î“(C, k_p) = k_p(C) = Îº(p) â‰… â„‚ (since p is a closed point on a proper curve).

    **Mathematical content:**
    The global sections Î“(C, k_p) is 1-dimensional over â„‚. -/
theorem globalSections_dim :
    -- Î“(C, k_p) â‰… Îº(p) as modules
    -- For now, express that the global sections module is isomorphic to itself
    -- (placeholder for the actual 1-dimensionality statement)
    Nonempty ((skyscraperModule C p).val.obj (Opposite.op âŠ¤) â‰…
              (skyscraperModule C p).val.obj (Opposite.op âŠ¤)) := by
  exact âŸ¨Iso.refl _âŸ©

end SkyscraperSheaf

/-!
## Skyscraper Sheaves are Flasque

This is the key property that implies HÂ¹ = 0.
-/

/-- Skyscraper sheaves are flasque.

    **Proof:**
    For a skyscraper sheaf k_p:
    - k_p(U) = Îº(p) if p âˆˆ U, else 0 (= terminal object PUnit)

    The restriction map k_p(V) â†’ k_p(U) for U âŠ† V is:
    - Identity Îº(p) â†’ Îº(p) if p âˆˆ U (hence p âˆˆ V by U â‰¤ V)
    - The unique map Îº(p) â†’ 0 if p âˆ‰ U but p âˆˆ V
    - The zero map 0 â†’ 0 if p âˆ‰ V (hence p âˆ‰ U)

    All these maps are surjective:
    - Case 1: id : Îº(p) â†’ Îº(p) is surjective (trivially)
    - Case 2: Îº(p) â†’ 0 is surjective (0 is terminal, unique preimage)
    - Case 3: 0 â†’ 0 is surjective (trivially)

    **Key infrastructure:**
    - `skyscraper_restriction_surjective` in SkyscraperInfrastructure.lean
      proves surjectivity for each case separately. -/
instance skyscraperModule_isFlasque (p : C.PointType) :
    IsFlasque (skyscraperModule C p) where
  restriction_surjective := fun U V hUV => by
    exact SkyscraperConstruction.skyscraperMap_surjective
      (X := C.toScheme) p (homOfLE hUV).op

/-!
## Cohomology of Skyscraper Sheaves

The key fact for Riemann-Roch: skyscraper sheaves have Euler characteristic 1.
-/

/-- hâ°(k_p) = 1.

    **Proof:**
    Hâ°(C, k_p) = CechCocycles(k_p, ğ’°, 0) is 1-dimensional over â„‚.
    We apply `finrank_eq_one_iff_of_nonzero'` with the constant 1 cocycle:
    1. `constantCocycle_one_ne_zero`: the constant 1 cocycle is nonzero
    2. `skyscraper_cocycle_scalar_multiple`: every cocycle is a â„‚-scalar multiple
       of the constant 1 cocycle

    **Key infrastructure from SkyscraperCohomology.lean:**
    - `constantCocycle` : nonzero element of Hâ°(k_p)
    - `skyscraper_cocycle_scalar_multiple` : every element is a scalar multiple -/
theorem h0_skyscraper (C : ProperCurve) (p : C.toAlgebraicCurve.PointType) :
    h_i C 0 (skyscraperSheaf C.toAlgebraicCurve p) = 1 := by
  unfold h_i
  -- SheafCohomology C 0 (skyscraperModule C p) = CechCocycles (skyPresheaf C p) ğ’° 0
  -- where ğ’° = standardAffineCover C (all definitional)
  let ğ’° := standardAffineCover C.toAlgebraicCurve
  -- Provide the â„‚-module instance on CechCocycles explicitly
  -- (CechCohomology0.module is registered on CechCohomology0, not CechCocycles directly)
  letI : Module â„‚ (CechCocycles (SkyscraperH0.skyPresheaf C.toAlgebraicCurve p) ğ’° 0) :=
    CechCohomology0.module C.toAlgebraicCurve _ ğ’°
  -- finrank = 1 iff every element is a scalar multiple of a nonzero element
  apply (finrank_eq_one_iff_of_nonzero'
    (SkyscraperH0.constantCocycle C.toAlgebraicCurve p ğ’° 1)
    (SkyscraperH0.constantCocycle_one_ne_zero C.toAlgebraicCurve p ğ’°)).mpr
  intro w
  exact SkyscraperH0.skyscraper_cocycle_scalar_multiple C.toAlgebraicCurve p ğ’° w

/-- hÂ¹(k_p) = 0 (skyscraper sheaves are acyclic).

    **Proof:**
    This follows from the fact that k_p is a flasque (flabby) sheaf:
    - k_p is supported on a single point
    - Restriction maps are either identity or zero-to-zero
    - Flasque sheaves have vanishing higher cohomology (flasque_H1_zero)

    **Detailed proof:**
    1. k_p is flasque (from skyscraperModule_isFlasque)
    2. Flasque sheaves have HÂ¹ = 0 (from flasque_H1_zero in FlasqueSheaves.lean)
    3. HÂ¹ = 0 implies finrank â„‚ HÂ¹ = 0, hence hÂ¹ = 0

    **Key infrastructure:**
    - `skyscraperModule_isFlasque` : k_p is flasque
    - `flasque_H1_zero` : F flasque â‡’ HÂ¹(F) = 0 -/
theorem h1_skyscraper (C : ProperCurve) (p : C.toAlgebraicCurve.PointType) :
    h_i C 1 (skyscraperSheaf C.toAlgebraicCurve p) = 0 := by
  -- k_p is flasque (skyscraperModule_isFlasque), so hÂ¹ = 0
  haveI : IsFlasque (skyscraperSheaf C.toAlgebraicCurve p).toModule :=
    skyscraperModule_isFlasque C.toAlgebraicCurve p
  exact flasque_h1_eq_zero C (skyscraperSheaf C.toAlgebraicCurve p)

/-- Ï‡(k_p) = 1.

    **Proof:**
    Ï‡(k_p) = hâ°(k_p) - hÂ¹(k_p) = 1 - 0 = 1.

    This is the key fact used in the inductive proof of Riemann-Roch. -/
theorem euler_char_skyscraper (C : ProperCurve) (p : C.toAlgebraicCurve.PointType) :
    EulerChar C (skyscraperSheaf C.toAlgebraicCurve p) = 1 := by
  unfold EulerChar
  rw [h0_skyscraper C p, h1_skyscraper C p]
  norm_num

end RiemannSurfaces.SchemeTheoretic
