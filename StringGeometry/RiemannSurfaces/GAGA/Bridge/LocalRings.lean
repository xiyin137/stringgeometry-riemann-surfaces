/-
Copyright (c) 2026 ModularPhysics Authors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: ModularPhysics Contributors
-/
import StringGeometry.RiemannSurfaces.GAGA.AlgebraicCurves.FunctionField
import StringGeometry.RiemannSurfaces.GAGA.Helpers.DVRStructure
import Mathlib.RingTheory.DiscreteValuationRing.Basic
import Mathlib.RingTheory.LocalRing.ResidueField.Defs
import Mathlib.RingTheory.Valuation.ValuationSubring

/-!
# Local Ring Infrastructure for Bridge to Scheme Theory

This file develops the local ring theory needed to construct a scheme from
`CompactAlgebraicCurve`. The key insight is that the valuations in
`CompactAlgebraicCurve` determine DVR local rings at each point, which
can be assembled into a scheme.

## Main Definitions

* `ValuationSubring` - The subring {f : v_p(f) ≥ 0} of the function field
* `MaximalIdeal` - The ideal {f : v_p(f) > 0}
* `ValuationSubring.isDVR` - Proof that valuation rings are DVRs

## Mathematical Background

For a compact algebraic curve C over ℂ:
1. Each point p determines a discrete valuation v_p on K(C)
2. The valuation ring O_p = {f : v_p(f) ≥ 0} is a DVR
3. The maximal ideal m_p = {f : v_p(f) > 0} is principal (generated by local parameter)
4. The residue field O_p/m_p ≅ ℂ (from leadingCoefficientUniqueness)

These properties are exactly what's needed to construct a smooth proper curve scheme.

## References

* Hartshorne "Algebraic Geometry" II.6
* Neukirch "Algebraic Number Theory" Chapter I
-/

namespace RiemannSurfaces.GAGA.Bridge

open Algebraic

variable (C : CompactAlgebraicCurve)

/-!
## Valuation Subring

The valuation subring at p is O_p = {f ∈ K(C) : v_p(f) ≥ 0}.
This is the ring of functions regular at p.
-/

/-- The valuation subring at a point p.
    This is the local ring O_{C,p} = {f ∈ K(C) : v_p(f) ≥ 0}. -/
def ValuationSubringAt (p : C.Point) : Subring C.FunctionField :=
  Algebraic.LocalRingAt C.toAlgebraicCurve p

/-- Membership in the valuation subring -/
theorem mem_valuationSubringAt (p : C.Point) (f : C.FunctionField) :
    f ∈ ValuationSubringAt C p ↔ 0 ≤ C.valuation p f := by
  rfl

/-- The maximal ideal at a point p.
    m_p = {f ∈ K(C) : v_p(f) > 0} -/
def MaximalIdealAt (p : C.Point) : Set C.FunctionField :=
  Algebraic.MaximalIdealAt C.toAlgebraicCurve p

/-- Membership in the maximal ideal -/
theorem mem_maximalIdealAt (p : C.Point) (f : C.FunctionField) :
    f ∈ MaximalIdealAt C p ↔ 0 < C.valuation p f := by
  rfl

/-!
## Local Ring Properties

We show that ValuationSubringAt is indeed a local ring with maximal ideal MaximalIdealAt.
-/

/-- The maximal ideal is an additive subgroup -/
theorem maximalIdealAt_add_mem (p : C.Point) (f g : C.FunctionField)
    (hf : f ∈ MaximalIdealAt C p) (hg : g ∈ MaximalIdealAt C p) :
    f + g ∈ MaximalIdealAt C p ∨ f + g = 0 := by
  by_cases hfg : f + g = 0
  · exact Or.inr hfg
  · left
    simp only [mem_maximalIdealAt] at *
    have h := C.toAlgebraicCurve.valuation_add_min p f g hfg
    omega

/-- The maximal ideal is closed under multiplication by ring elements -/
theorem maximalIdealAt_mul_mem (p : C.Point) (f : C.FunctionField) (r : C.FunctionField)
    (hf : f ∈ MaximalIdealAt C p) (hr : r ∈ ValuationSubringAt C p) :
    r * f ∈ MaximalIdealAt C p ∨ r * f = 0 := by
  by_cases hrf : r * f = 0
  · exact Or.inr hrf
  · left
    simp only [mem_maximalIdealAt, mem_valuationSubringAt] at *
    have hr_ne : r ≠ 0 := fun h => by simp [h] at hrf
    have hf_ne : f ≠ 0 := fun h => by simp [h] at hrf
    rw [C.toAlgebraicCurve.valuation_mul p r f hr_ne hf_ne]
    omega

/-- An element not in the maximal ideal is a unit in the valuation ring -/
theorem isUnit_of_not_in_maximalIdeal (p : C.Point) (f : C.FunctionField)
    (hf_ring : f ∈ ValuationSubringAt C p) (hf_not_max : f ∉ MaximalIdealAt C p)
    (hf_ne : f ≠ 0) :
    ∃ g ∈ ValuationSubringAt C p, f * g = 1 := by
  simp only [mem_valuationSubringAt, mem_maximalIdealAt] at *
  push_neg at hf_not_max
  have hval : C.valuation p f = 0 := by omega
  use f⁻¹
  constructor
  · -- f⁻¹ ∈ ValuationSubringAt
    rw [C.toAlgebraicCurve.valuation_inv p f hf_ne, hval]
    norm_num
  · -- f * f⁻¹ = 1
    exact mul_inv_cancel₀ hf_ne

/-!
## Local Parameter Properties

The local parameter t_p generates the maximal ideal m_p.
-/

/-- The local parameter is in the maximal ideal -/
theorem localParameter_in_maximalIdeal (p : C.Point) :
    C.localParameter p ∈ MaximalIdealAt C p := by
  simp only [mem_maximalIdealAt]
  rw [C.localParameter_valuation]
  omega

/-- The local parameter is not zero -/
theorem localParameter_ne_zero (p : C.Point) : C.localParameter p ≠ 0 := by
  intro h
  have := C.localParameter_valuation p
  rw [h, C.toAlgebraicCurve.valuation_zero] at this
  omega

/-- Powers of the local parameter have the expected valuation -/
theorem localParameter_pow_valuation (p : C.Point) (n : ℕ) :
    C.valuation p (C.localParameter p ^ n) = n := by
  induction n with
  | zero => simp [C.toAlgebraicCurve.valuation_one]
  | succ n ih =>
    rw [pow_succ]
    have ht_ne := localParameter_ne_zero C p
    have hpow_ne : C.localParameter p ^ n ≠ 0 := pow_ne_zero n ht_ne
    rw [C.toAlgebraicCurve.valuation_mul p _ _ hpow_ne ht_ne, ih, C.localParameter_valuation]
    omega

/-- Integer powers of the local parameter have the expected valuation -/
theorem localParameter_zpow_valuation (p : C.Point) (n : ℤ) :
    C.valuation p (C.localParameter p ^ n) = n := by
  cases n with
  | ofNat k =>
    simp only [Int.ofNat_eq_natCast, zpow_natCast]
    exact_mod_cast localParameter_pow_valuation C p k
  | negSucc k =>
    simp only [zpow_negSucc]
    have hpow_ne : C.localParameter p ^ (k + 1) ≠ 0 :=
      pow_ne_zero (k + 1) (localParameter_ne_zero C p)
    rw [C.toAlgebraicCurve.valuation_inv p _ hpow_ne]
    have := localParameter_pow_valuation C p (k + 1)
    omega

/-!
## DVR Structure

We show that ValuationSubringAt is a discrete valuation ring.
The key properties are:
1. It's a local ring (unique maximal ideal)
2. The maximal ideal is principal (generated by local parameter)
3. It's Noetherian
-/

/-- Every element f with v_p(f) = n can be written as u * t^n where u is a unit -/
theorem exists_unit_mul_localParameter_pow (p : C.Point) (f : C.FunctionField) (hf : f ≠ 0) :
    ∃ (u : C.FunctionField), u ∈ ValuationSubringAt C p ∧ u ∉ MaximalIdealAt C p ∧
      f = u * C.localParameter p ^ (C.valuation p f) := by
  -- The unit is f / t^{v_p(f)}
  let n := C.valuation p f
  let t := C.localParameter p
  have ht_ne := localParameter_ne_zero C p
  have htn_ne : t ^ n ≠ 0 := zpow_ne_zero n ht_ne
  use f * (t ^ n)⁻¹
  constructor
  · -- u ∈ ValuationSubringAt
    simp only [mem_valuationSubringAt]
    have h1 : C.valuation p (f * (t ^ n)⁻¹) = C.valuation p f - n := by
      rw [C.toAlgebraicCurve.valuation_mul p f _ hf (inv_ne_zero htn_ne)]
      rw [C.toAlgebraicCurve.valuation_inv p (t ^ n) htn_ne]
      rw [localParameter_zpow_valuation]
      ring
    rw [h1]
    omega
  constructor
  · -- u ∉ MaximalIdealAt (i.e., v_p(u) = 0)
    simp only [mem_maximalIdealAt]
    push_neg
    have h1 : C.valuation p (f * (t ^ n)⁻¹) = 0 := by
      rw [C.toAlgebraicCurve.valuation_mul p f _ hf (inv_ne_zero htn_ne)]
      rw [C.toAlgebraicCurve.valuation_inv p (t ^ n) htn_ne]
      rw [localParameter_zpow_valuation]
      ring
    omega
  · -- f = u * t^n
    -- Goal: f = (f * (t^n)⁻¹) * t^n
    rw [mul_assoc, inv_mul_cancel₀ htn_ne, mul_one]

/-- The valuation ring is a local ring (existence of unique maximal ideal) -/
theorem valuationSubringAt_isLocalRing (p : C.Point) :
    ∀ f ∈ ValuationSubringAt C p, f ∉ MaximalIdealAt C p → f ≠ 0 →
      ∃ g ∈ ValuationSubringAt C p, f * g = 1 :=
  fun f hf hf_not hf_ne => isUnit_of_not_in_maximalIdeal C p f hf hf_not hf_ne

/-!
## Leading Coefficient and Residue Field

The residue field O_p/m_p is isomorphic to ℂ. This is captured by
leadingCoefficientUniqueness in CompactAlgebraicCurve.
-/

/-- The leading coefficient of f at p.
    For f with v_p(f) = n, write f = c * t^n + (higher order terms).
    The leading coefficient is c ∈ ℂ*. -/
noncomputable def leadingCoeff (p : C.Point) (f : C.FunctionField) (hf : f ≠ 0) : ℂ :=
  Classical.choose (C.leadingCoefficientUniquenessGeneral p
    (C.localParameter p ^ (C.valuation p f))
    f
    (zpow_ne_zero _ (localParameter_ne_zero C p))
    hf
    (localParameter_zpow_valuation C p _))

/-- The leading coefficient is nonzero -/
theorem leadingCoeff_ne_zero (p : C.Point) (f : C.FunctionField) (hf : f ≠ 0) :
    leadingCoeff C p f hf ≠ 0 := by
  unfold leadingCoeff
  exact (Classical.choose_spec (C.leadingCoefficientUniquenessGeneral p
    (C.localParameter p ^ (C.valuation p f)) f
    (zpow_ne_zero _ (localParameter_ne_zero C p)) hf
    (localParameter_zpow_valuation C p _))).1

/-- The leading coefficient captures the residue: f - c*t^n has higher valuation -/
theorem leadingCoeff_spec (p : C.Point) (f : C.FunctionField) (hf : f ≠ 0) :
    let c := leadingCoeff C p f hf
    let n := C.valuation p f
    let t := C.localParameter p
    f - @algebraMap ℂ C.FunctionField _ _ C.algebraInst.algebraInst c * t ^ n = 0 ∨
    C.valuation p (f - @algebraMap ℂ C.FunctionField _ _ C.algebraInst.algebraInst c * t ^ n) > n := by
  unfold leadingCoeff
  exact (Classical.choose_spec (C.leadingCoefficientUniquenessGeneral p
    (C.localParameter p ^ (C.valuation p f)) f
    (zpow_ne_zero _ (localParameter_ne_zero C p)) hf
    (localParameter_zpow_valuation C p _))).2

/-!
## Summary

The local ring structure at each point of a `CompactAlgebraicCurve` is fully characterized:

1. **ValuationSubringAt** is the local ring O_p
2. **MaximalIdealAt** is the unique maximal ideal m_p
3. **localParameter** generates m_p
4. **leadingCoeff** gives the residue class in ℂ

These properties establish that O_p is a DVR with residue field ℂ,
which is exactly what's needed to construct a smooth proper curve scheme.
-/

end RiemannSurfaces.GAGA.Bridge
